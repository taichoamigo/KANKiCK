<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>激闘！缶蹴りサバイバル</title>
    <style>
        /* フォント読み込み（失敗しても遊べるようにsans-serifをフォールバック） */
        @import url('https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Kosugi Maru', sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none; /* テキスト選択防止 */
            -webkit-user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            background: linear-gradient(to bottom, #4a3b32, #2c241f);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 1.2rem;
            z-index: 20;
            font-weight: bold;
        }

        .stage-indicator {
            color: #ffcc00;
            font-size: 1.5rem;
        }

        .stamina-bar-container {
            width: 150px;
            height: 15px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }

        #staminaBar {
            width: 100%;
            height: 100%;
            background: #00ffcc;
            transform-origin: left;
            transition: width 0.1s;
        }

        /* Mobile Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: auto;
            display: none;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
            z-index: 20;
        }

        .joystick-area {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 35px;
            left: 35px;
            pointer-events: none;
        }

        .action-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 0.5);
            border-radius: 50%;
            border: 2px solid white;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
            margin-top: 20px;
        }
        
        .action-btn:active {
            background: rgba(255, 50, 50, 0.8);
            transform: scale(0.95);
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            z-index: 30;
            transition: opacity 0.3s;
        }

        .screen h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: #ffcc00;
            text-shadow: 4px 4px 0 #cc3300;
        }

        .screen p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.6;
            max-width: 80%;
        }

        .btn {
            background: #ffcc00;
            color: #330000;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Kosugi Maru', sans-serif;
            font-weight: bold;
            box-shadow: 0 5px 0 #cc9900;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
            opacity: 0;
        }

        /* Overlay Text (Level Clear etc) */
        #overlayText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: white;
            text-shadow: 0 0 20px #00ffcc;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 25;
            text-align: center;
            white-space: nowrap;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <div id="uiLayer">
        <div class="hud-top">
            <div class="stage-indicator">STAGE <span id="stageNum">1</span></div>
            <div style="text-align: right;">
                STAMINA
                <div class="stamina-bar-container">
                    <div id="staminaBar"></div>
                </div>
            </div>
        </div>
        
        <div id="controls">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
            <div class="action-btn" id="sprintBtn">ダッシュ</div>
        </div>

        <div id="overlayText">STAGE CLEAR!</div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <h1>缶蹴りサバイバル</h1>
        <p>ステージが進むごとに鬼が増えるぞ！<br>
        物陰に隠れて缶を蹴り飛ばせ！<br><br>
        【操作】矢印/WASDで移動、Spaceでダッシュ</p>
        <button class="btn" id="startBtn">スタート</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen hidden">
        <h1 style="color: #ff3333;">確保された...</h1>
        <p>鬼「みーつけた！」<br><br>到達: STAGE <span id="finalStageNum">1</span></p>
        <button class="btn" id="retryBtn">最初から挑戦</button>
    </div>
</div>

<script>
    /**
     * ゲームの初期化処理
     * DOM読み込み完了後に実行することで、外部サイト埋め込み時のエラーを防ぎます。
     */
    window.addEventListener('load', function() {
        initGameSystem();
    });

    // --- Global Variables ---
    let canvas, ctx, staminaBar, stageNumEl, finalStageNumEl, overlayText;
    let joystick, joystickKnob, sprintBtn;
    let startScreen, gameOverScreen, controlsDiv;
    
    // Game State
    let gameState = 'START'; 
    let level = 1;
    let isMobile = false;
    let lastTime = 0;

    // Inputs
    const keys = {
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        w: false, s: false, a: false, d: false,
        " ": false, Shift: false
    };
    const input = { x: 0, y: 0, sprint: false };

    // Game Objects
    const world = { width: 0, height: 0 };
    let player, can;
    let onis = []; 
    let obstacles = [];
    let particles = [];

    // --- Classes (Defined first to allow safe usage) ---

    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mult(n) { return new Vector(this.x * n, this.y * n); }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() {
            let m = this.mag();
            return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m);
        }
        dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
    }

    class Obstacle {
        constructor(x, y, w, h) {
            this.x = x; this.y = y; this.w = w; this.h = h;
        }
        draw() {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(this.x + 8, this.y + 8, this.w, this.h);
            ctx.fillStyle = '#556';
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.fillStyle = '#6e6e80';
            ctx.fillRect(this.x, this.y, this.w, 8);
            ctx.fillStyle = '#334';
            ctx.fillRect(this.x + this.w - 5, this.y, 5, this.h);
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.pos = new Vector(x, y);
            this.vel = new Vector((Math.random()-0.5)*12, (Math.random()-0.5)*12);
            this.life = 1.0;
            this.color = color;
        }
        update() {
            this.pos = this.pos.add(this.vel);
            this.vel = this.vel.mult(0.92);
            this.life -= 0.03;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Can {
        constructor(x, y) {
            this.pos = new Vector(x, y);
            this.radius = 12;
            this.isKicked = false;
            this.vel = new Vector(0,0);
            this.angle = 0;
        }
        update() {
            if (this.isKicked) {
                this.pos = this.pos.add(this.vel);
                this.angle += 0.5;
                if (Math.random() > 0.6) {
                    particles.push(new Particle(this.pos.x, this.pos.y, '#ffd700'));
                }
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.angle);
            
            if (!this.isKicked) {
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(5, 5, this.radius, this.radius/2, 0, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    class Player {
        constructor(x, y) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, 0);
            this.radius = 15;
            this.baseSpeed = 3.5;
            this.sprintSpeed = 6.5;
            this.stamina = 100;
            this.maxStamina = 100;
            this.color = '#00aaff';
        }

        checkObstacleCollision(x, y) {
            for (let obs of obstacles) {
                let testX = x;
                let testY = y;
                if (x < obs.x) testX = obs.x;
                else if (x > obs.x + obs.w) testX = obs.x + obs.w;
                if (y < obs.y) testY = obs.y;
                else if (y > obs.y + obs.h) testY = obs.y + obs.h;
                
                let dist = Math.sqrt(Math.pow(x - testX, 2) + Math.pow(y - testY, 2));
                if (dist < this.radius) return true;
            }
            return false;
        }

        update() {
            let dir = new Vector(0, 0);
            if (input.x !== 0 || input.y !== 0) {
                dir.x = input.x; dir.y = input.y;
            } else {
                if (keys.ArrowUp || keys.w) dir.y = -1;
                if (keys.ArrowDown || keys.s) dir.y = 1;
                if (keys.ArrowLeft || keys.a) dir.x = -1;
                if (keys.ArrowRight || keys.d) dir.x = 1;
            }

            if (dir.mag() > 0) dir = dir.normalize();

            let currentSpeed = this.baseSpeed;
            let isSprinting = (keys[' '] || keys.Shift || input.sprint);

            if (isSprinting && this.stamina > 0 && dir.mag() > 0) {
                currentSpeed = this.sprintSpeed;
                this.stamina -= 1.2;
            } else {
                if (this.stamina < this.maxStamina) this.stamina += 0.4;
            }

            this.vel = dir.mult(currentSpeed);
            
            // Wall Sliding
            let nextX = this.pos.x + this.vel.x;
            let hitX = false;
            if (nextX < this.radius) { nextX = this.radius; hitX = true; }
            if (nextX > world.width - this.radius) { nextX = world.width - this.radius; hitX = true; }
            if (!hitX && this.checkObstacleCollision(nextX, this.pos.y)) hitX = true;
            if (!hitX) this.pos.x = nextX;

            let nextY = this.pos.y + this.vel.y;
            let hitY = false;
            if (nextY < this.radius) { nextY = this.radius; hitY = true; }
            if (nextY > world.height - this.radius) { nextY = world.height - this.radius; hitY = true; }
            if (!hitY && this.checkObstacleCollision(this.pos.x, nextY)) hitY = true;
            if (!hitY) this.pos.y = nextY;

            if (staminaBar) staminaBar.style.width = (this.stamina / this.maxStamina * 100) + '%';
        }

        draw() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(this.pos.x, this.pos.y + 5, this.radius, this.radius/2, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Oni {
        constructor(x, y, role, difficulty) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0,0);
            this.radius = 16;
            this.role = role; 

            // Difficulty Tuning
            let speedMod = Math.min(difficulty * 0.12, 1.5); 
            this.speed = 1.8 + speedMod; 
            this.chaseSpeed = 3.8 + (difficulty * 0.2);
            if (this.chaseSpeed > 5.5) this.chaseSpeed = 5.5;

            // Vision Tuning
            this.viewDistance = 210 + (difficulty * 5); 
            this.viewAngle = Math.PI / 2.8; 

            if (role === 'SEARCHER') {
                this.viewAngle = Math.PI / 4; 
                this.viewDistance = 180 + (difficulty * 5); 
                this.speed *= 0.9; 
            }
            
            this.color = role === 'GUARD' ? '#cc0000' : '#ff5500';
            this.facing = new Vector(1, 0); 
            
            this.state = 'PATROL'; 
            this.patrolTarget = null;
            this.alertTimer = 0;
            this.waitTime = 0;
            this.scanDirection = 1;
        }

        pickPatrolPoint() {
            if (this.role === 'GUARD') {
                let angle = Math.random() * Math.PI * 2;
                let dist = 30 + Math.random() * 100; 
                this.patrolTarget = can.pos.add(new Vector(Math.cos(angle)*dist, Math.sin(angle)*dist));
            } else {
                this.patrolTarget = new Vector(
                    30 + Math.random() * (world.width - 60),
                    30 + Math.random() * (world.height - 60)
                );
            }
            // Screen bounds check
            if (this.patrolTarget.x < 30) this.patrolTarget.x = 30;
            if (this.patrolTarget.x > world.width - 30) this.patrolTarget.x = world.width - 30;
            if (this.patrolTarget.y < 30) this.patrolTarget.y = 30;
            if (this.patrolTarget.y > world.height - 30) this.patrolTarget.y = world.height - 30;
        }

        canSeePlayer(p) {
            let dist = this.pos.dist(p.pos);
            if (dist > this.viewDistance) return false;
            let dirToPlayer = p.pos.sub(this.pos).normalize();
            let angleBetween = Math.acos(this.facing.x * dirToPlayer.x + this.facing.y * dirToPlayer.y);
            if (angleBetween < this.viewAngle / 2) {
                for (let obs of obstacles) {
                    if (lineRectIntersect(this.pos.x, this.pos.y, p.pos.x, p.pos.y, obs.x, obs.y, obs.w, obs.h)) {
                        return false; 
                    }
                }
                return true;
            }
            return false;
        }

        update() {
            let currentSpd = this.speed;
            if (this.canSeePlayer(player)) {
                this.state = 'CHASE';
                this.alertTimer = 90;
                this.waitTime = 0;
            }

            if (this.state === 'CHASE') {
                this.patrolTarget = player.pos;
                currentSpd = this.chaseSpeed;
                if (!this.canSeePlayer(player)) {
                    this.alertTimer--;
                    if (this.alertTimer <= 0) {
                        this.state = 'RETURN';
                        this.patrolTarget = null;
                    }
                }
            } else if (this.state === 'RETURN') {
                if (!this.patrolTarget) this.patrolTarget = can.pos;
                if (this.pos.dist(can.pos) < 60) {
                    this.state = 'PATROL';
                    this.waitTime = 40;
                    this.patrolTarget = null;
                }
            } else if (this.state === 'PATROL') {
                if (this.waitTime > 0) {
                    this.waitTime--;
                    let currentAngle = Math.atan2(this.facing.y, this.facing.x);
                    let rotationSpeed = 0.05 * this.scanDirection;
                    if (this.waitTime % 40 === 0) this.scanDirection *= -1;
                    let newAngle = currentAngle + rotationSpeed;
                    this.facing = new Vector(Math.cos(newAngle), Math.sin(newAngle));
                    return; 
                }
                if (!this.patrolTarget) this.pickPatrolPoint();
                if (this.pos.dist(this.patrolTarget) < 15) {
                    this.patrolTarget = null;
                    this.waitTime = 30 + Math.random() * 60; 
                    this.scanDirection = Math.random() > 0.5 ? 1 : -1;
                }
            }

            if (this.patrolTarget) {
                let desired = this.patrolTarget.sub(this.pos).normalize();
                obstacles.forEach(obs => {
                    let obsCenter = new Vector(obs.x + obs.w/2, obs.y + obs.h/2);
                    let dist = this.pos.dist(obsCenter);
                    if (dist < 60) {
                        let push = this.pos.sub(obsCenter).normalize();
                        desired = desired.add(push.mult(0.6)).normalize();
                    }
                });
                onis.forEach(other => {
                    if (other !== this) {
                        let dist = this.pos.dist(other.pos);
                        if (dist < 40) {
                            let push = this.pos.sub(other.pos).normalize();
                            desired = desired.add(push.mult(0.8)).normalize();
                        }
                    }
                });
                this.vel = desired.mult(currentSpd);
                let nextPos = this.pos.add(this.vel);
                if(nextPos.x < 0) nextPos.x = 0;
                if(nextPos.x > world.width) nextPos.x = world.width;
                if(nextPos.y < 0) nextPos.y = 0;
                if(nextPos.y > world.height) nextPos.y = world.height;
                
                this.pos = nextPos;
                if (this.vel.mag() > 0.1) {
                    let moveAngle = Math.atan2(this.vel.y, this.vel.x);
                    let faceAngle = Math.atan2(this.facing.y, this.facing.x);
                    let diff = moveAngle - faceAngle;
                    while (diff > Math.PI) diff -= Math.PI*2;
                    while (diff < -Math.PI) diff += Math.PI*2;
                    let turnSpeed = 0.15;
                    let newFaceAngle = faceAngle + diff * turnSpeed;
                    this.facing = new Vector(Math.cos(newFaceAngle), Math.sin(newFaceAngle));
                }
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            let faceAngle = Math.atan2(this.facing.y, this.facing.x);
            
            // Vision Cone
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = this.state === 'CHASE' ? '#ff0000' : (this.role === 'GUARD' ? '#ffaa00' : '#ffff00');
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.viewDistance, faceAngle - this.viewAngle/2, faceAngle + this.viewAngle/2);
            ctx.lineTo(0,0);
            ctx.fill();
            
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = this.state === 'CHASE' ? '#ff0000' : '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.arc(0,0, this.viewDistance, faceAngle - this.viewAngle/2, faceAngle + this.viewAngle/2);
            ctx.lineTo(0,0);
            ctx.stroke();

            ctx.globalAlpha = 1.0;
            ctx.rotate(faceAngle);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(5, -10); ctx.lineTo(12, -5); ctx.lineTo(5, -2); ctx.fill();
            if (this.role === 'GUARD') { 
                ctx.beginPath();
                ctx.moveTo(5, 10); ctx.lineTo(12, 5); ctx.lineTo(5, 2); ctx.fill();
            }

            if (this.state === 'CHASE') {
                ctx.restore();
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('!', this.pos.x - 5, this.pos.y - 25);
            } else if (this.waitTime > 0 && this.state === 'PATROL') {
                ctx.restore();
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('?', this.pos.x - 5, this.pos.y - 25);
            } else {
                ctx.restore();
            }
        }
    }

    // --- Core Functions ---

    function initGameSystem() {
        // DOM Elements
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        staminaBar = document.getElementById('staminaBar');
        stageNumEl = document.getElementById('stageNum');
        finalStageNumEl = document.getElementById('finalStageNum');
        overlayText = document.getElementById('overlayText');
        joystick = document.getElementById('joystick');
        joystickKnob = document.getElementById('joystickKnob');
        sprintBtn = document.getElementById('sprintBtn');
        startScreen = document.getElementById('startScreen');
        gameOverScreen = document.getElementById('gameOverScreen');
        controlsDiv = document.getElementById('controls');

        // Button Listeners (Robust binding)
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('retryBtn').addEventListener('click', startGame); // Retry also starts game

        // Window Resize
        window.addEventListener('resize', resize);
        resize();

        // Input Listeners
        window.addEventListener('keydown', e => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
            if(e.key === ' ' && (gameState === 'START' || gameState === 'GAMEOVER')) startGame();
        });
        window.addEventListener('keyup', e => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = false;
        });

        setupTouchControls();
    }

    function lineRectIntersect(x1, y1, x2, y2, rx, ry, rw, rh) {
        let dist = Math.sqrt(Math.pow(x2-x1,2) + Math.pow(y2-y1,2));
        let steps = dist / 15; 
        for(let i=0; i<=steps; i++) {
            let t = i/steps;
            let cx = x1 + (x2-x1)*t;
            let cy = y1 + (y2-y1)*t;
            if (cx >= rx && cx <= rx+rw && cy >= ry && cy <= ry+rh) return true;
        }
        return false;
    }

    function resize() {
        if (!canvas) return; // Guard
        canvas.width = document.getElementById('gameContainer').clientWidth;
        canvas.height = document.getElementById('gameContainer').clientHeight;
        world.width = canvas.width;
        world.height = canvas.height;
        
        isMobile = ('ontouchstart' in window) || (window.innerWidth <= 800);
        if (isMobile && gameState === 'PLAYING') {
            controlsDiv.style.display = 'flex';
        } else {
            controlsDiv.style.display = 'none';
        }
    }

    function initLevel() {
        resize();
        obstacles = [];
        particles = [];
        
        can = new Can(world.width/2, world.height/2);
        
        // Map Gen
        obstacles.push(new Obstacle(100, 100, 100, 50));
        obstacles.push(new Obstacle(world.width - 200, 100, 50, 100));
        obstacles.push(new Obstacle(100, world.height - 200, 100, 100));
        obstacles.push(new Obstacle(world.width - 250, world.height - 150, 150, 50));
        
        let obsCount = 4 + Math.floor(level / 2); 
        if (obsCount > 8) obsCount = 8;
        for(let i=0; i<obsCount; i++) {
            let w = 60 + Math.random() * 60;
            let h = 60 + Math.random() * 60;
            let x = 100 + Math.random() * (world.width - 200);
            let y = 100 + Math.random() * (world.height - 200);
            if (Math.abs(x - world.width/2) > 130 || Math.abs(y - world.height/2) > 130) {
                 obstacles.push(new Obstacle(x, y, w, h));
            }
        }

        player = new Player(50, 50);

        onis = [];
        let oniCount = 1;
        if (level >= 3) oniCount = 2; 
        if (level >= 6) oniCount = 3;
        if (level >= 10) oniCount = 4;

        for(let i=0; i<oniCount; i++) {
            let role = (i === 0) ? 'GUARD' : 'SEARCHER';
            let ox = world.width - 50;
            let oy = world.height - 50;
            if (i === 1) { ox = world.width - 50; oy = 50; }
            if (i === 2) { ox = 50; oy = world.height - 50; }
            onis.push(new Oni(ox, oy, role, level));
        }

        if(stageNumEl) stageNumEl.innerText = level;
    }

    function startGame() {
        level = 1;
        startLevel();
    }

    function startLevel() {
        initLevel();
        gameState = 'PLAYING';
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        if(overlayText) overlayText.style.opacity = 0;
        
        if (isMobile) controlsDiv.style.display = 'flex';
        gameLoop();
    }

    function nextLevelTransition() {
        gameState = 'TRANSITION';
        if(overlayText) {
            overlayText.innerText = "STAGE " + level + " CLEAR!";
            overlayText.style.opacity = 1;
        }
        
        setTimeout(() => {
            level++;
            if(overlayText) overlayText.style.opacity = 0;
            setTimeout(() => {
                startLevel();
            }, 500);
        }, 2000);
    }

    function resetGame() {
        startScreen.classList.remove('hidden');
        gameOverScreen.classList.add('hidden');
        gameState = 'START';
    }

    function gameLoop() {
        if (gameState !== 'PLAYING' && gameState !== 'TRANSITION') return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === 'PLAYING') {
            player.update();
            onis.forEach(oni => oni.update());
            can.update();

            // Win
            if (!can.isKicked && player.pos.dist(can.pos) < (player.radius + can.radius + 5)) {
                can.isKicked = true;
                let kickDir = can.pos.sub(player.pos).normalize();
                can.vel = kickDir.mult(18);
                for(let i=0; i<40; i++) {
                    particles.push(new Particle(can.pos.x, can.pos.y, `hsl(${Math.random()*360}, 100%, 50%)`));
                }
                nextLevelTransition();
            }

            // Lose
            let caught = false;
            onis.forEach(oni => {
                if (player.pos.dist(oni.pos) < (player.radius + oni.radius - 5)) {
                    caught = true;
                }
            });

            if (caught) {
                gameState = 'GAMEOVER';
                if(finalStageNumEl) finalStageNumEl.innerText = level;
                gameOverScreen.classList.remove('hidden');
                controlsDiv.style.display = 'none';
            }
        } else {
            can.update();
        }

        for(let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }

        // Draw
        ctx.strokeStyle = '#332a25';
        ctx.lineWidth = 1;
        let gridSize = 50;
        ctx.beginPath();
        for(let x=0; x<world.width; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x, world.height); }
        for(let y=0; y<world.height; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(world.width, y); }
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.beginPath();
        ctx.arc(world.width/2, world.height/2, 80, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 2;
        ctx.stroke();

        obstacles.forEach(o => o.draw());
        can.draw();
        particles.forEach(p => p.draw());
        player.draw();
        onis.forEach(oni => oni.draw());

        requestAnimationFrame(gameLoop);
    }

    function setupTouchControls() {
        let touchId = null;
        joystick.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchId = touch.identifier;
        }, {passive: false});

        joystick.addEventListener('touchmove', e => {
            e.preventDefault();
            for (let i=0; i<e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    let touch = e.changedTouches[i];
                    let rect = joystick.getBoundingClientRect();
                    let centerX = rect.left + rect.width/2;
                    let centerY = rect.top + rect.height/2;
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let maxDist = 35; 
                    if (dist > maxDist) {
                        dx = (dx/dist) * maxDist;
                        dy = (dy/dist) * maxDist;
                    }
                    joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
                    input.x = dx / maxDist;
                    input.y = dy / maxDist;
                }
            }
        }, {passive: false});

        const endJoystick = (e) => {
            e.preventDefault();
            for (let i=0; i<e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    touchId = null;
                    input.x = 0; input.y = 0;
                    joystickKnob.style.transform = `translate(0px, 0px)`;
                }
            }
        };
        joystick.addEventListener('touchend', endJoystick);
        joystick.addEventListener('touchcancel', endJoystick);

        sprintBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            input.sprint = true;
            sprintBtn.style.transform = "scale(0.9)";
        }, {passive: false});
        sprintBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            input.sprint = false;
            sprintBtn.style.transform = "scale(1)";
        }, {passive: false});
    }

</script>
</body>
</html>
